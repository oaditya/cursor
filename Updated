<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cursor Animation</title>
    <style>
        body, html {
            padding: 0;
            margin: 0;
            overscroll-behavior: none;
            background-color: #000;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <script>
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      let lines = [];
      const pointer = { x: canvas.width / 2, y: canvas.height / 2, px: canvas.width / 2, py: canvas.height / 2, moved: false };
      const colors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];

      function Line(x, y, color) {
          this.x = x;
          this.y = y;
          this.px = x;
          this.py = y;
          this.vx = 0;
          this.vy = 0;
          this.color = color;
          this.angle = Math.random() * Math.PI * 2;
          this.history = []; // Array to store previous positions
          this.alpha = 1; // Initial alpha value
      }

      function setup() {
          for (let i = 0; i < 30; i++) {
              const color = colors[Math.floor(Math.random() * colors.length)];
              lines.push(new Line(pointer.x, pointer.y, color));
          }
      }

      function draw() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          lines.forEach(line => {
              // Draw lines between history points
              for (let i = 0; i < line.history.length - 1; i++) {
                  ctx.beginPath();
                  ctx.moveTo(line.history[i].x, line.history[i].y);
                  ctx.lineTo(line.history[i + 1].x, line.history[i + 1].y);

                  // Apply transparency for a blur effect
                  ctx.globalAlpha = line.alpha;

                  ctx.strokeStyle = line.color;
                  ctx.lineWidth = 2;
                  ctx.stroke();

                  // Reduce alpha for the next segment
                  line.alpha *= 0.96;
              }

              // Update history with current position
              line.history.push({ x: line.x, y: line.y });

              // Limit history length to create trailing effect
              if (line.history.length > 20) {
                  line.history.shift(); // Remove oldest position
              }

              // Calculate distance to mouse pointer
              const dx = pointer.x - line.x;
              const dy = pointer.y - line.y;
              const dist = Math.sqrt(dx * dx + dy * dy);

              if (pointer.moved && dist > 2) {
                  const angle = Math.atan2(dy, dx);

                  line.vx += Math.cos(angle) * 0.3; // Adjust this factor to control speed towards pointer
                  line.vy += Math.sin(angle) * 0.3;

              } else {
                  line.angle += 0.05;
                  line.vx = Math.cos(line.angle) * 2;
                  line.vy = Math.sin(line.angle) * 2;
              }

              line.vx *= 0.95;
              line.vy *= 0.95;

              line.x += line.vx;
              line.y += line.vy;

              // Reset alpha for next frame
              line.alpha = 1;
          });

          pointer.px = pointer.x;
          pointer.py = pointer.y;
          pointer.moved = false;

          requestAnimationFrame(draw);
      }

      window.addEventListener('resize', () => {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
      });

      window.addEventListener('mousemove', (e) => {
          pointer.x = e.clientX;
          pointer.y = e.clientY;
          pointer.moved = true;
      });

      setup();
      draw();

    </script>
</body>
</html>
